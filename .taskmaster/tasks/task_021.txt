# Task ID: 21
# Title: Implement Error Handling and Logging
# Status: done
# Dependencies: 13, 14, 15, 16, 17, 18, 19, 20
# Priority: medium
# Description: Enhance the parser with comprehensive error handling and logging to handle edge cases and provide useful diagnostics.
# Details:
Add comprehensive error handling and logging throughout the parser. Handle common failure scenarios gracefully. Log warnings for skipped transactions or minor issues. Raise clear exceptions for critical errors. Ensure the parser fails gracefully with informative error messages when the PDF structure changes.

```python
import logging

# Set up logging
logger = logging.getLogger(__name__)

# Update methods to use proper logging
def parse_file(self, file_path):
    """Parse a single CapitalOne Visa PDF statement"""
    if not os.path.exists(file_path):
        logger.error(f"File not found: {file_path}")
        raise FileNotFoundError(f"File not found: {file_path}")
        
    try:
        logger.info(f"Parsing file: {file_path}")
        transactions = []
        with pdfplumber.open(file_path) as pdf:
            # Extract text from each page
            all_text = ""
            for page in pdf.pages:
                page_text = page.extract_text()
                if page_text:
                    all_text += page_text + "\n"
            
            if not all_text.strip():
                logger.warning(f"No text content extracted from {file_path}")
                return []
                    
            # Extract transactions from the text
            transactions = self.extract_transactions(all_text, file_path)
            logger.info(f"Extracted {len(transactions)} transactions from {file_path}")
            
        return transactions
    except Exception as e:
        logger.error(f"Error parsing PDF file {file_path}: {str(e)}", exc_info=True)
        raise Exception(f"Error parsing PDF file {file_path}: {str(e)}")

# Similarly update other methods with appropriate logging
# ...

# Add validation method
def validate_transactions(self, transactions):
    """Validate extracted transactions"""
    valid_transactions = []
    for i, transaction in enumerate(transactions):
        is_valid = True
        missing_fields = []
        
        # Check required fields
        for field in ['transaction_date', 'description', 'amount']:
            if field not in transaction or not transaction[field]:
                missing_fields.append(field)
                is_valid = False
        
        if not is_valid:
            logger.warning(f"Skipping transaction {i+1} due to missing required fields: {', '.join(missing_fields)}")
            continue
        
        valid_transactions.append(transaction)
    
    if len(valid_transactions) < len(transactions):
        logger.warning(f"Filtered out {len(transactions) - len(valid_transactions)} invalid transactions")
    
    return valid_transactions

# Update extract_transactions to use validation
def extract_transactions(self, text_content, file_path):
    # Existing extraction code
    # ...
    
    # Validate transactions before returning
    return self.validate_transactions(transactions)
```

# Test Strategy:
Test with various edge cases: missing fields, malformed dates, invalid amounts, unexpected PDF structures. Verify that appropriate warnings and errors are logged. Check that valid transactions are processed correctly while invalid ones are skipped with warnings.
