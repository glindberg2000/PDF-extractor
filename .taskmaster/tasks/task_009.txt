# Task ID: 9
# Title: Implement Unit Tests for Core Components
# Status: pending
# Dependencies: 2, 3, 4
# Priority: high
# Description: Create comprehensive unit tests for the core parser components, including the BaseParser, ParserRegistry, and configuration system.
# Details:
Create a `tests` directory with the following structure and test files:

```
tests/
  __init__.py
  test_base_parser.py
  test_registry.py
  test_config.py
  parsers/
    __init__.py
    test_chase_checking.py
  cli/
    __init__.py
    test_commands.py
  django/
    __init__.py
    test_management_command.py
    test_adapters.py
```

Implement `test_base_parser.py`:

```python
import pytest
from dataextractai.parsers_core.base import BaseParser
from typing import Dict, Any, Union, Optional, IO
from pathlib import Path

# Create a concrete implementation for testing
class TestParser(BaseParser):
    @property
    def name(self) -> str:
        return "test_parser"
        
    @property
    def description(self) -> str:
        return "Test parser implementation"
    
    @classmethod
    def get_supported_file_types(cls) -> list[str]:
        return ["txt", "csv"]
    
    def parse(self, 
              input_source: Union[str, Path, IO], 
              output_destination: Optional[Union[str, Path, IO]] = None,
              **kwargs) -> Dict[str, Any]:
        return {"result": "test_data"}

def test_base_parser_is_abstract():
    """Test that BaseParser cannot be instantiated directly."""
    with pytest.raises(TypeError):
        BaseParser()

def test_concrete_parser_instantiation():
    """Test that a concrete implementation can be instantiated."""
    parser = TestParser()
    assert parser.name == "test_parser"
    assert parser.description == "Test parser implementation"

def test_validate_input_with_valid_extension():
    """Test validation with valid file extension."""
    parser = TestParser()
    assert parser.validate_input("test.txt") is True
    assert parser.validate_input(Path("test.csv")) is True

def test_validate_input_with_invalid_extension():
    """Test validation with invalid file extension."""
    parser = TestParser()
    assert parser.validate_input("test.pdf") is False
    assert parser.validate_input(Path("test.docx")) is False

def test_parse_method():
    """Test the parse method returns expected data."""
    parser = TestParser()
    result = parser.parse("test.txt")
    assert result == {"result": "test_data"}
```

Implement `test_registry.py`:

```python
import pytest
from dataextractai.parsers_core.registry import ParserRegistry
from dataextractai.parsers_core.base import BaseParser

# Reset registry before tests
@pytest.fixture(autouse=True)
def clear_registry():
    ParserRegistry._parsers = {}

# Create test parsers
class TestParser1(BaseParser):
    @property
    def name(self) -> str:
        return "test_parser1"
        
    @property
    def description(self) -> str:
        return "Test parser 1"
    
    @classmethod
    def get_supported_file_types(cls) -> list[str]:
        return ["txt"]
    
    def parse(self, input_source, output_destination=None, **kwargs):
        return {"result": "test1"}

class TestParser2(BaseParser):
    @property
    def name(self) -> str:
        return "test_parser2"
        
    @property
    def description(self) -> str:
        return "Test parser 2"
    
    @classmethod
    def get_supported_file_types(cls) -> list[str]:
        return ["csv"]
    
    def parse(self, input_source, output_destination=None, **kwargs):
        return {"result": "test2"}

def test_register_parser():
    """Test registering a parser class."""
    ParserRegistry.register(TestParser1)
    assert "test_parser1" in ParserRegistry._parsers
    assert ParserRegistry._parsers["test_parser1"] == TestParser1

def test_register_parser_as_decorator():
    """Test registering a parser using decorator syntax."""
    @ParserRegistry.register
    class DecoratedParser(BaseParser):
        @property
        def name(self) -> str:
            return "decorated_parser"
            
        @property
        def description(self) -> str:
            return "Decorated parser"
        
        def parse(self, input_source, output_destination=None, **kwargs):
            return {"result": "decorated"}
    
    assert "decorated_parser" in ParserRegistry._parsers
    assert ParserRegistry._parsers["decorated_parser"] == DecoratedParser

def test_get_parser_class():
    """Test retrieving a parser class by name."""
    ParserRegistry.register(TestParser1)
    parser_class = ParserRegistry.get_parser_class("test_parser1")
    assert parser_class == TestParser1
    assert ParserRegistry.get_parser_class("nonexistent") is None

def test_get_parser_for_file():
    """Test finding a parser for a file based on extension."""
    ParserRegistry.register(TestParser1)
    ParserRegistry.register(TestParser2)
    
    parser_class = ParserRegistry.get_parser_for_file("test.txt")
    assert parser_class == TestParser1
    
    parser_class = ParserRegistry.get_parser_for_file("test.csv")
    assert parser_class == TestParser2
    
    assert ParserRegistry.get_parser_for_file("test.pdf") is None

def test_list_parsers():
    """Test listing all registered parsers."""
    ParserRegistry.register(TestParser1)
    ParserRegistry.register(TestParser2)
    
    parsers = ParserRegistry.list_parsers()
    assert len(parsers) == 2
    
    parser_names = [p["name"] for p in parsers]
    assert "test_parser1" in parser_names
    assert "test_parser2" in parser_names
```

Implement `test_config.py`:

```python
import pytest
import os
import tempfile
import json
import yaml
from pathlib import Path
from dataextractai.parsers_core.utils.config import ConfigLoader, ParserConfig

def test_parser_config_from_dict():
    """Test creating ParserConfig from dictionary."""
    config = ParserConfig.from_dict({
        "input_path": "test.pdf",
        "output_path": "output.csv",
        "parser_name": "test_parser",
        "parser_options": {"option1": "value1"}
    })
    
    assert config.input_path == "test.pdf"
    assert config.output_path == "output.csv"
    assert config.parser_name == "test_parser"
    assert config.parser_options == {"option1": "value1"}

def test_load_config_from_env(monkeypatch):
    """Test loading configuration from environment variables."""
    monkeypatch.setenv("DATAEXTRACTAI_INPUT_PATH", "env_test.pdf")
    monkeypatch.setenv("DATAEXTRACTAI_PARSER_NAME", "env_parser")
    
    config = ConfigLoader.load_config()
    
    assert config.input_path == "env_test.pdf"
    assert config.parser_name == "env_parser"

def test_load_config_from_json_file():
    """Test loading configuration from JSON file."""
    with tempfile.NamedTemporaryFile(suffix=".json", mode="w+", delete=False) as f:
        json.dump({
            "input_path": "json_test.pdf",
            "parser_name": "json_parser"
        }, f)
    
    try:
        config = ConfigLoader.load_config(config_path=f.name)
        assert config.input_path == "json_test.pdf"
        assert config.parser_name == "json_parser"
    finally:
        os.unlink(f.name)

def test_load_config_from_yaml_file():
    """Test loading configuration from YAML file."""
    try:
        import yaml
        with tempfile.NamedTemporaryFile(suffix=".yaml", mode="w+", delete=False) as f:
            yaml.dump({
                "input_path": "yaml_test.pdf",
                "parser_name": "yaml_parser"
            }, f)
        
        try:
            config = ConfigLoader.load_config(config_path=f.name)
            assert config.input_path == "yaml_test.pdf"
            assert config.parser_name == "yaml_parser"
        finally:
            os.unlink(f.name)
    except ImportError:
        pytest.skip("PyYAML not installed")

def test_cli_args_override_file_and_env(monkeypatch):
    """Test that CLI args override file and environment configs."""
    monkeypatch.setenv("DATAEXTRACTAI_INPUT_PATH", "env_test.pdf")
    
    with tempfile.NamedTemporaryFile(suffix=".json", mode="w+", delete=False) as f:
        json.dump({
            "input_path": "json_test.pdf",
            "parser_name": "json_parser"
        }, f)
    
    try:
        config = ConfigLoader.load_config(
            cli_args={
                "input_path": "cli_test.pdf",
                "parser_name": None  # Should not override
            },
            config_path=f.name
        )
        
        assert config.input_path == "cli_test.pdf"  # CLI overrides
        assert config.parser_name == "json_parser"  # File overrides env
    finally:
        os.unlink(f.name)
```

# Test Strategy:
Run the unit tests with pytest:
1. Verify all tests pass
2. Check test coverage to ensure all core functionality is tested
3. Test edge cases and error conditions
4. Ensure tests are isolated and don't depend on external resources
5. Verify tests run in CI environment
