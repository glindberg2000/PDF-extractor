# Task ID: 12
# Title: Ensure Backward Compatibility
# Status: pending
# Dependencies: 6, 9, 10
# Priority: high
# Description: Verify and ensure backward compatibility with existing workflows, particularly for CLI users.
# Details:
Create a compatibility layer to ensure existing workflows continue to work:

1. Create wrapper scripts or aliases that maintain the same command-line interface as before.

2. Create a backward compatibility module in `dataextractai/compat.py`:

```python
import sys
import os
import warnings
from pathlib import Path
from .parsers_core import ParserRegistry
from .cli.commands import run_parser_command

def run_legacy_parser(parser_name, input_file, output_file=None, **options):
    """Run a parser using the legacy interface.
    
    This function maintains backward compatibility with code that used the
    previous parser system directly.
    
    Args:
        parser_name: Name of the parser to use
        input_file: Path to input file
        output_file: Optional path to output file
        **options: Additional parser-specific options
    
    Returns:
        Parsed data
    """
    warnings.warn(
        "Using legacy parser interface. Consider updating to the new API.",
        DeprecationWarning,
        stacklevel=2
    )
    
    parser_class = ParserRegistry.get_parser_class(parser_name)
    if not parser_class:
        raise ValueError(f"Parser '{parser_name}' not found")
    
    parser = parser_class()
    return parser.parse(
        input_source=input_file,
        output_destination=output_file,
        **options
    )

def legacy_cli_entry():
    """Entry point for legacy CLI scripts.
    
    This function maintains backward compatibility with existing shell scripts
    that called the old parser system.
    """
    # Map old argument format to new format
    if len(sys.argv) < 2:
        print("Error: Input file required")
        sys.exit(1)
    
    input_file = sys.argv[1]
    
    # Check for old-style flags and convert them
    args = [input_file]
    i = 2
    while i < len(sys.argv):
        arg = sys.argv[i]
        if arg == "--parser":
            if i + 1 < len(sys.argv):
                args.extend(["-p", sys.argv[i+1]])
                i += 2
            else:
                print("Error: --parser requires a value")
                sys.exit(1)
        elif arg == "--output":
            if i + 1 < len(sys.argv):
                args.extend(["-o", sys.argv[i+1]])
                i += 2
            else:
                print("Error: --output requires a value")
                sys.exit(1)
        else:
            # Pass through other arguments
            args.append(arg)
            i += 1
    
    # Run the new command with translated arguments
    return run_parser_command(args)
```

3. Create legacy entry points in `setup.py`:

```python
entry_points={
    'console_scripts': [
        'parsefile=dataextractai.cli.commands:main',
        # Legacy entry points
        'run_parser=dataextractai.compat:legacy_cli_entry',
        'parse_chase=dataextractai.compat:legacy_cli_entry',
    ],
},
```

4. Create a compatibility test script in `tests/compat/test_backward_compatibility.py`:

```python
import pytest
import subprocess
import os
import tempfile
from pathlib import Path

# Create a test file
@pytest.fixture
def test_file():
    with tempfile.NamedTemporaryFile(suffix=".txt", delete=False) as f:
        f.write(b"Test content for backward compatibility")
    try:
        yield f.name
    finally:
        os.unlink(f.name)

# Setup mock parser for testing
@pytest.fixture
def setup_mock_parser():
    # Similar to previous test fixtures
    # ...

def test_legacy_function_call(setup_mock_parser, test_file):
    """Test calling the legacy function directly."""
    from dataextractai.compat import run_legacy_parser
    
    with pytest.warns(DeprecationWarning):
        result = run_legacy_parser(
            parser_name="mock_parser",
            input_file=test_file,
            output_file="output.txt"
        )
    
    assert result is not None

def test_legacy_cli_command(setup_mock_parser, test_file):
    """Test the legacy CLI command."""
    output_file = tempfile.NamedTemporaryFile(suffix=".txt", delete=False).name
    
    try:
        result = subprocess.run(
            [
                "python", "-m", "dataextractai.compat",
                test_file,
                "--parser", "mock_parser",
                "--output", output_file
            ],
            capture_output=True,
            text=True
        )
        
        assert result.returncode == 0
        assert "Successfully parsed" in result.stdout
        assert os.path.exists(output_file)
    finally:
        if os.path.exists(output_file):
            os.unlink(output_file)
```

5. Document the backward compatibility in `docs/backward_compatibility.md`:

```markdown
# Backward Compatibility

The parser system maintains backward compatibility with existing workflows, particularly for CLI users.

## Legacy CLI Commands

If you were using the old parser system with commands like:

```bash
run_parser input.pdf --parser chase_checking --output output.csv
```

These commands will continue to work with the new system. However, we recommend migrating to the new CLI format:

```bash
parsefile input.pdf -p chase_checking -o output.csv
```

## Legacy Python API

If you were using the old parser system directly in Python code:

```python
from old_parser_system import parse_chase

result = parse_chase("input.pdf", "output.csv")
```

You can use the compatibility layer:

```python
from dataextractai.compat import run_legacy_parser

result = run_legacy_parser(
    parser_name="chase_checking",
    input_file="input.pdf",
    output_file="output.csv"
)
```

However, we recommend migrating to the new API:

```python
from dataextractai.parsers_core import ParserRegistry

parser_class = ParserRegistry.get_parser_class("chase_checking")
parser = parser_class()
result = parser.parse(
    input_source="input.pdf",
    output_destination="output.csv"
)
```
```

# Test Strategy:
Verify backward compatibility:
1. Test legacy function calls with the compatibility layer
2. Test legacy CLI commands with the same arguments as before
3. Verify that deprecation warnings are shown but functionality works
4. Test with actual legacy scripts if available
5. Ensure documentation clearly explains the migration path
